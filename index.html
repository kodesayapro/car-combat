<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Car Combat</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, height=device-height" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta http-equiv="ScreenOrientation" content="autoRotate:disabled" />
    <link rel="manifest" href="manifest.json" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* Root Variables */
      :root {
        --app-height: 100%;
        --control-btn-size: clamp(50px, 15vw, 80px);
        --shoot-btn-size: clamp(60px, 20vw, 100px);
      }

      /* Basic Layout */
      html,
      body {
        width: 100%;
        height: 100%;
        height: var(--app-height);
        overflow: hidden;
        position: fixed;
        background-color: #f8fcfa;
        -webkit-user-select: none;
        user-select: none;
        touch-action: manipulation;
      }

      #game-container {
        width: 100%;
        height: 100%;
        position: relative;
        overflow: hidden;
      }

      canvas {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      .game-controls {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 2;
      }

      .controls-left,
      .controls-right {
        position: absolute;
        bottom: max(20px, 2vh);
        display: flex;
        gap: 10px;
      }

      /* Controls Container Styles */
      .controls-left {
        position: absolute;
        bottom: max(20px, 2vh);
        left: max(20px, 2vw);
        display: grid;
        grid-template-areas:
          ". gasBtn ."
          "leftBtn . rightBtn"
          ". brakeBtn .";
        gap: clamp(10px, 2vw, 20px);
        pointer-events: auto; /* Mengaktifkan kembali pointer events untuk tombol */
      }

      /* Button Positioning */
      #leftBtn {
        grid-area: leftBtn;
      }
      #rightBtn {
        grid-area: rightBtn;
      }
      #gasBtn {
        grid-area: gasBtn;
        background: rgba(0, 255, 0, 0.3);
      }
      #brakeBtn {
        grid-area: brakeBtn;
        background: rgba(255, 0, 0, 0.3);
      }

      /* Control Button Base Styles */
      .control-btn {
        width: clamp(50px, 15vw, 80px);
        height: clamp(50px, 15vw, 80px);
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(5px);
        color: white;
        font-size: clamp(16px, 4vw, 24px);
        font-weight: bold;
        cursor: pointer;
        touch-action: manipulation;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
      }

      .controls-right {
        right: max(20px, 2vw);
        flex-direction: column;
      }

      #shootBtn {
        width: clamp(60px, 20vw, 100px);
        height: clamp(60px, 20vw, 100px);
        font-size: clamp(20px, 5vw, 30px);
        background: rgba(255, 0, 0, 0.3);
      }

      /* Reload Indicator */
      #shootBtn::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: #ff0000;
        transform: scaleX(0);
        transform-origin: left;
        transition: transform var(--reload-time, 1000ms) linear;
      }

      #shootBtn.reloading::after {
        transform: scaleX(1);
      }

      /* Button States */
      .control-btn:active {
        transform: scale(0.95);
        background: rgba(255, 255, 255, 0.5) !important;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      /* HP Display */
      .hp-display {
        position: fixed;
        padding: clamp(8px, 2vw, 15px) clamp(15px, 3vw, 25px);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        font-size: clamp(14px, 3vw, 18px);
        z-index: 1000;
      }

      #playerHp {
        top: max(20px, 2vh);
        left: max(20px, 2vw);
      }

      #targetedBy {
        top: max(60px, 6vh);
        left: max(20px, 2vw);
        color: #ff4444;
      }

      /* Game Over Screen */
      .game-over {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: clamp(20px, 4vw, 40px);
        border-radius: 10px;
        text-align: center;
        color: white;
        z-index: 1001;
        width: clamp(280px, 90vw, 400px);
      }

      .game-over h2 {
        font-size: clamp(24px, 5vw, 32px);
        margin-bottom: 15px;
      }

      .game-over p {
        font-size: clamp(16px, 3vw, 20px);
        margin-bottom: 20px;
      }

      .game-over input {
        width: clamp(100px, 50%, 200px);
        padding: 8px;
        font-size: clamp(14px, 3vw, 18px);
        margin: 10px 0;
      }

      .game-over button {
        padding: clamp(8px, 2vw, 15px) clamp(15px, 3vw, 25px);
        font-size: clamp(16px, 3vw, 20px);
        background: #4caf50;
        border: none;
        border-radius: 5px;
        color: white;
        cursor: pointer;
        transition: background 0.3s ease;
      }

      .game-over button:hover {
        background: #45a049;
      }

      /* Landscape mode */
      @media (orientation: landscape) {
        #shootBtn {
          width: min(80px, 15vmin);
          height: min(80px, 15vmin);
        }
      }

      /* Portrait mode */
      @media (orientation: portrait) {
        #game-container {
          transform: rotate(-90deg);
          width: 100vh;
          height: 100vw;
          position: absolute;
          top: 50%;
          left: 50%;
          margin-top: -50vw;
          margin-left: -50vh;
        }

        .controls-right,
        .controls-left {
          transform: rotate(90deg);
          bottom: 20px;
          right: 20px;
        }
      }

      @supports (-webkit-touch-callout: none) {
        .control-btn {
          /* Prevent double-tap zoom on iOS */
          touch-action: manipulation;
        }
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <canvas id="gameCanvas"></canvas>
      <div class="game-controls">
        <div class="controls-left">
          <button class="control-btn" id="gasBtn">GAS</button>
          <button class="control-btn" id="leftBtn">‚Üê</button>
          <button class="control-btn" id="rightBtn">‚Üí</button>
          <button class="control-btn" id="brakeBtn">BRAKE</button>
        </div>
        <div class="controls-right">
          <button class="control-btn" id="shootBtn">üéØ</button>
        </div>
      </div>
    </div>
    <script>
      // Fix for iOS vh units
      function setVH() {
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty("--vh", `${vh}px`);
      }

      // Handle orientation lock and resize
      async function setupOrientation() {
        try {
          if (screen.orientation && screen.orientation.lock) {
            await screen.orientation.lock("landscape");
          }
        } catch (err) {
          console.log("Orientation lock failed:", err);
        }
      }

      // Initialize
      window.addEventListener("load", async () => {
        setVH();
        await setupOrientation();

        if ("serviceWorker" in navigator) {
          try {
            await navigator.serviceWorker.register("service-worker.js");
          } catch (error) {
            console.error("Service worker registration failed:", error);
          }
        }
      });

      // Handle resizing and orientation changes
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          setVH();
          window.dispatchEvent(new Event("resize"));
        }, 150);
      });

      window.addEventListener("orientationchange", () => {
        setTimeout(setVH, 100);
      });

      // Prevent bouncing/scrolling on iOS
      document.body.addEventListener(
        "touchmove",
        (e) => {
          if (e.target.classList.contains("control-btn")) return;
          e.preventDefault();
        },
        { passive: false }
      );

      // Deklarasi variabel global di awal
      let camera, scene, renderer, car, road;
      let bots = [];
      let bullets = [];
      let numberOfBots = 0;
      let isMovingForward = false;
      let isMovingBackward = false;
      let isTurningLeft = false;
      let isTurningRight = false;
      let carRotation = 0;
      let playerHp = 10;
      let botsHp = new Map(); // Menyimpan HP setiap bot
      let canShoot = true; // Deklarasi canShoot sekali saja
      let isGameOver = false;
      let playerLabelSystem;
      let tempQuaternion;

      // Konstanta
      const ROAD_SIZE = 200;
      const BARRIER_HEIGHT = 2;
      const BULLET_SPEED = 2;
      const RELOAD_TIME = 10; // 1 detik
      const BULLET_LIFETIME = 2000;
      const TURN_SPEED = 0.03;
      const MOVE_SPEED = 0.5;
      const BRAKE_SPEED = 0.25;
      const BOT_TURN_SPEED = 0.02;
      const BOT_SPEED = 0.3;

      function showBotInput() {
        const inputContainer = document.createElement("div");
        inputContainer.className = "game-dialog";

        inputContainer.innerHTML = `
        <div class="dialog-content">
            <h1>Tank Drive Arena</h1>
            <h2>Choose Your Battle!</h2>
            <div class="input-group">
                <label for="botCount">Number of Bots (1-50):</label>
                <input type="number" id="botCount" min="1" max="50" value="5" class="bot-input">
                <div class="input-controls">
                    <button class="adjust-btn" onclick="adjustBotCount(-1)">-</button>
                    <button class="adjust-btn" onclick="adjustBotCount(1)">+</button>
                </div>
            </div>
            <button id="startGame" class="action-btn">START BATTLE</button>
        </div>
    `;

        document.body.appendChild(inputContainer);

        window.adjustBotCount = function (delta) {
          const input = document.getElementById("botCount");
          let value = parseInt(input.value) + delta;
          value = Math.min(Math.max(value, 1), 50);
          input.value = value;
        };

        document.getElementById("startGame").addEventListener("click", () => {
          numberOfBots = Math.min(
            50,
            Math.max(1, parseInt(document.getElementById("botCount").value))
          );
          document.body.removeChild(inputContainer);
          initGame(); // Menggunakan fungsi initGame yang sudah ada
        });
      }

      function showGameOver() {
        isGameOver = true;

        const gameOverDiv = document.createElement("div");
        gameOverDiv.className = "game-dialog";

        gameOverDiv.innerHTML = `
        <div class="dialog-content">
            <h1>Game Over!</h1>
            <div class="stats">
                <p>Bots Destroyed: ${numberOfBots - bots.length}</p>
            </div>
            <div class="input-group">
                <label for="botCountRestart">Number of Bots for Next Battle:</label>
                <input type="number" id="botCountRestart" min="1" max="50" value="${numberOfBots}" class="bot-input">
                <div class="input-controls">
                    <button class="adjust-btn" onclick="adjustRestartBotCount(-1)">-</button>
                    <button class="adjust-btn" onclick="adjustRestartBotCount(1)">+</button>
                </div>
            </div>
            <button id="restartButton" class="action-btn">RESTART BATTLE</button>
        </div>
    `;

        document.body.appendChild(gameOverDiv);

        window.adjustRestartBotCount = function (delta) {
          const input = document.getElementById("botCountRestart");
          let value = parseInt(input.value) + delta;
          value = Math.min(Math.max(value, 1), 50);
          input.value = value;
        };

        document
          .getElementById("restartButton")
          .addEventListener("click", () => {
            const botCount = Math.min(
              50,
              Math.max(
                1,
                parseInt(document.getElementById("botCountRestart").value)
              )
            );
            document.body.removeChild(gameOverDiv);
            numberOfBots = botCount;
            restartGame(); // Menggunakan fungsi restartGame yang sudah ada
          });
      }

      function showBotSelectionScreen() {
        isGameOver = true;

        const selectionDiv = document.createElement("div");
        selectionDiv.className = "game-dialog";

        selectionDiv.innerHTML = `
        <div class="dialog-content">
            <h1>Victory!</h1>
            <h2>All Bots Defeated!</h2>
            <div class="stats">
                <p>Health Remaining: ${playerHp}/10</p>
            </div>
            <div class="input-group">
                <label for="newBotCount">Number of Bots for Next Round:</label>
                <input type="number" id="newBotCount" min="1" max="50" value="${numberOfBots}" class="bot-input">
                <div class="input-controls">
                    <button class="adjust-btn" onclick="adjustNewBotCount(-1)">-</button>
                    <button class="adjust-btn" onclick="adjustNewBotCount(1)">+</button>
                </div>
            </div>
            <button id="nextRoundBtn" class="action-btn">START NEXT ROUND</button>
        </div>
    `;

        document.body.appendChild(selectionDiv);

        window.adjustNewBotCount = function (delta) {
          const input = document.getElementById("newBotCount");
          let value = parseInt(input.value) + delta;
          value = Math.min(Math.max(value, 1), 50);
          input.value = value;
        };

        document
          .getElementById("nextRoundBtn")
          .addEventListener("click", () => {
            const botCount = Math.min(
              50,
              Math.max(
                1,
                parseInt(document.getElementById("newBotCount").value)
              )
            );
            document.body.removeChild(selectionDiv);
            numberOfBots = botCount;
            restartGame(); // Menggunakan fungsi restartGame yang sudah ada
          });
      }
      // Tambahkan CSS untuk styling dialog
      const dialogStyles = document.createElement("style");
      dialogStyles.textContent = `
.game-dialog {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.dialog-content {
    background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
    padding: clamp(20px, 5vw, 40px);
    border-radius: 20px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    text-align: center;
    width: clamp(280px, 90vw, 500px);
    max-height: 90vh;
    overflow-y: auto;
}

.dialog-content h1 {
    color: #ff3e3e;
    font-size: clamp(28px, 6vw, 48px);
    margin-bottom: 20px;
    text-transform: uppercase;
    text-shadow: 0 0 10px rgba(255, 62, 62, 0.5);
}

.dialog-content h2 {
    color: #fff;
    font-size: clamp(20px, 4vw, 32px);
    margin-bottom: 30px;
}

.input-group {
    margin: 20px 0;
    padding: 15px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
}

.input-group label {
    display: block;
    color: #fff;
    font-size: clamp(16px, 3vw, 20px);
    margin-bottom: 10px;
}

.bot-input {
    width: 80%;
    padding: 12px;
    font-size: clamp(18px, 4vw, 24px);
    background: rgba(255, 255, 255, 0.9);
    border: none;
    border-radius: 8px;
    text-align: center;
    margin: 10px 0;
}

.input-controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 10px;
}

.adjust-btn {
    width: 40px;
    height: 40px;
    font-size: 24px;
    background: rgba(255, 255, 255, 0.2);
    border: none;
    border-radius: 8px;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
}

.adjust-btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

.action-btn {
    background: linear-gradient(45deg, #ff3e3e, #ff8f8f);
    border: none;
    padding: clamp(12px, 3vw, 20px) clamp(24px, 6vw, 40px);
    font-size: clamp(18px, 4vw, 24px);
    color: white;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    font-weight: bold;
    margin-top: 20px;
}

.action-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(255, 62, 62, 0.4);
}

.stats {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    margin: 20px 0;
}

.stats p {
    color: #fff;
    font-size: clamp(16px, 3vw, 20px);
    margin: 10px 0;
}

@media (max-height: 600px) {
    .dialog-content {
        padding: 15px;
        max-height: 85vh;
    }
    
    .action-btn {
        padding: 10px 20px;
        margin-top: 10px;
    }
    
    .input-group {
        margin: 10px 0;
        padding: 10px;
    }
}

@media (max-width: 360px) {
    .dialog-content {
        width: 95vw;
        padding: 15px;
    }
    
    .bot-input {
        width: 90%;
        padding: 8px;
    }
}
`;

      document.head.appendChild(dialogStyles);

      function startGame() {
        const botCount = parseInt(document.getElementById("botCount").value);
        document.body.removeChild(document.querySelector("div"));
        initializeGame(botCount);
      }

      function init() {
        showBotInput();
      }

      function initializeGame(botCount) {
        // Inisialisasi Three.js
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        // Inisialisasi camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 20, -20);

        // Inisialisasi renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Inisialisasi tempQuaternion
        tempQuaternion = new THREE.Quaternion();

        // Setup game components
        setupLighting();
        createRoad();
        createCar();

        // Create bots
        for (let i = 0; i < botCount; i++) {
          const bot = createBot(i);
          bots.push(bot);
        }

        // Setup controls
        setupControls();

        // Start animation loop
        animate();
      }

      function updateCarPosition() {
        if (!car) return;

        if (isTurningLeft) carRotation += TURN_SPEED;
        if (isTurningRight) carRotation -= TURN_SPEED;
        car.rotation.y = carRotation;

        let moveX = 0;
        let moveZ = 0;

        if (isMovingForward) {
          moveX = Math.sin(carRotation) * MOVE_SPEED;
          moveZ = Math.cos(carRotation) * MOVE_SPEED;
        }
        if (isMovingBackward) {
          moveX = -Math.sin(carRotation) * BRAKE_SPEED;
          moveZ = -Math.cos(carRotation) * BRAKE_SPEED;
        }

        const proposedX = car.position.x + moveX;
        const proposedZ = car.position.z + moveZ;

        const halfRoad = ROAD_SIZE / 2 - 2;
        const isWithinBounds =
          Math.abs(proposedX) < halfRoad && Math.abs(proposedZ) < halfRoad;

        if (isWithinBounds) {
          car.position.x = proposedX;
          car.position.z = proposedZ;
        }

        updateCamera();
      }

      function updateCamera() {
        if (!camera || !car) return;

        const cameraDistance = 15;
        const cameraHeight = 8;
        const lookAheadDistance = 5;

        const targetCameraPos = new THREE.Vector3(
          car.position.x - Math.sin(carRotation) * cameraDistance,
          cameraHeight,
          car.position.z - Math.cos(carRotation) * cameraDistance
        );

        camera.position.lerp(targetCameraPos, 0.1);

        const lookAtPoint = new THREE.Vector3(
          car.position.x + Math.sin(carRotation) * lookAheadDistance,
          1,
          car.position.z + Math.cos(carRotation) * lookAheadDistance
        );
        camera.lookAt(lookAtPoint);
      }

      function animate() {
        if (!scene || !camera || !renderer || isGameOver) return;

        requestAnimationFrame(animate);

        // Update posisi mobil pemain
        if (car) {
          updateCarPosition();
        }

        // Update posisi dan AI bot jika ada bot yang aktif
        if (bots.length > 0) {
          bots.forEach((bot) => {
            if (bot) {
              updateBotAI(bot);
              updateBotMovement(bot);
            }
          });
          updateBotPositions(); // Pastikan label bot diperbarui
        }

        // Update peluru jika ada peluru yang aktif
        if (bullets.length > 0) {
          updateBullets();
        }

        // Render ulang scene
        renderer.render(scene, camera);
      }

      // Event listeners
      window.addEventListener("load", init);

      window.addEventListener("resize", () => {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });

      function setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
      }

      function createRoad() {
        const roadGeometry = new THREE.PlaneGeometry(ROAD_SIZE, ROAD_SIZE);
        const roadMaterial = new THREE.MeshPhongMaterial({
          color: 0x666666,
          specular: 0x222222,
          shininess: 30,
        });

        road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.receiveShadow = true;
        scene.add(road);

        createBarriers();
      }

      function createBarriers() {
        const barrierMaterial = new THREE.MeshPhongMaterial({
          color: 0xcccccc,
          specular: 0x333333,
          shininess: 30,
        });

        const barriers = [
          {
            pos: [ROAD_SIZE / 2, BARRIER_HEIGHT / 2, 0],
            scale: [2, BARRIER_HEIGHT, ROAD_SIZE],
          },
          {
            pos: [-ROAD_SIZE / 2, BARRIER_HEIGHT / 2, 0],
            scale: [2, BARRIER_HEIGHT, ROAD_SIZE],
          },
          {
            pos: [0, BARRIER_HEIGHT / 2, ROAD_SIZE / 2],
            scale: [ROAD_SIZE, BARRIER_HEIGHT, 2],
          },
          {
            pos: [0, BARRIER_HEIGHT / 2, -ROAD_SIZE / 2],
            scale: [ROAD_SIZE, BARRIER_HEIGHT, 2],
          },
        ];

        barriers.forEach((barrier) => {
          const barrierGeometry = new THREE.BoxGeometry(1, 1, 1);
          const barrierMesh = new THREE.Mesh(barrierGeometry, barrierMaterial);
          barrierMesh.position.set(...barrier.pos);
          barrierMesh.scale.set(...barrier.scale);
          barrierMesh.castShadow = true;
          barrierMesh.receiveShadow = true;
          scene.add(barrierMesh);
        });
      }

      function createCar() {
        const carGeometry = new THREE.Group();

        const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
        const bodyMaterial = new THREE.MeshPhongMaterial({
          color: 0xff4444,
          specular: 0x555555,
          shininess: 30,
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.8;
        body.castShadow = true;
        carGeometry.add(body);

        const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 32);
        const wheelMaterial = new THREE.MeshPhongMaterial({
          color: 0x333333,
          specular: 0x444444,
          shininess: 50,
        });

        const wheelPositions = [
          [-1, 0.4, 1.2],
          [1, 0.4, 1.2],
          [-1, 0.4, -1.2],
          [1, 0.4, -1.2],
        ];

        wheelPositions.forEach((pos) => {
          const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
          wheel.rotation.z = Math.PI / 2;
          wheel.position.set(...pos);
          wheel.castShadow = true;
          carGeometry.add(wheel);
        });

        const windowGeometry = new THREE.BoxGeometry(1.8, 0.8, 2);
        const windowMaterial = new THREE.MeshPhongMaterial({
          color: 0x87ceeb,
          transparent: true,
          opacity: 0.7,
          specular: 0xffffff,
          shininess: 100,
        });
        const carWindow = new THREE.Mesh(windowGeometry, windowMaterial);
        carWindow.position.y = 1.3;
        carGeometry.add(carWindow);

        car = carGeometry;
        car.position.y = 0.4;
        scene.add(car);

        // Tambahkan meriam di atas mobil
        const turret = createTurret();
        turret.position.y = 1.5;
        carGeometry.add(turret);

        car = carGeometry;
        car.position.y = 0.4;
        scene.add(car);

        playerLabelSystem = createLabel("Player");
        playerLabelSystem.sprite.position.y = 2.5; // Posisi tepat di atas mobil, sejajar dengan tinggi meriam
        carGeometry.add(playerLabelSystem.sprite);

        car = carGeometry;
        car.position.y = 0.4;
        scene.add(car);
      }

      function setupControls() {
        document.removeEventListener("mousedown", shoot);

        // Ambil referensi semua tombol control
        const gasBtn = document.getElementById("gasBtn");
        const brakeBtn = document.getElementById("brakeBtn");
        const leftBtn = document.getElementById("leftBtn");
        const rightBtn = document.getElementById("rightBtn");
        const shootBtn = document.getElementById("shootBtn");

        // Setup movement controls - Touch Events
        gasBtn.addEventListener("touchstart", () => (isMovingForward = true));
        gasBtn.addEventListener("touchend", () => (isMovingForward = false));
        brakeBtn.addEventListener(
          "touchstart",
          () => (isMovingBackward = true)
        );
        brakeBtn.addEventListener("touchend", () => (isMovingBackward = false));
        leftBtn.addEventListener("touchstart", () => (isTurningLeft = true));
        leftBtn.addEventListener("touchend", () => (isTurningLeft = false));
        rightBtn.addEventListener("touchstart", () => (isTurningRight = true));
        rightBtn.addEventListener("touchend", () => (isTurningRight = false));

        // Setup movement controls - Mouse Events
        gasBtn.addEventListener("mousedown", () => (isMovingForward = true));
        gasBtn.addEventListener("mouseup", () => (isMovingForward = false));
        gasBtn.addEventListener("mouseleave", () => (isMovingForward = false));

        brakeBtn.addEventListener("mousedown", () => (isMovingBackward = true));
        brakeBtn.addEventListener("mouseup", () => (isMovingBackward = false));
        brakeBtn.addEventListener(
          "mouseleave",
          () => (isMovingBackward = false)
        );

        leftBtn.addEventListener("mousedown", () => (isTurningLeft = true));
        leftBtn.addEventListener("mouseup", () => (isTurningLeft = false));
        leftBtn.addEventListener("mouseleave", () => (isTurningLeft = false));

        rightBtn.addEventListener("mousedown", () => (isTurningRight = true));
        rightBtn.addEventListener("mouseup", () => (isTurningRight = false));
        rightBtn.addEventListener("mouseleave", () => (isTurningRight = false));

        // Variabel untuk mengontrol auto-shooting
        let autoShootInterval = null;
        let isHolding = false;

        // Fungsi untuk memulai auto-shooting
        function startAutoShoot() {
          if (!isHolding) {
            isHolding = true;
            if (canShoot && !isGameOver) {
              shoot(car, true);
            }
            autoShootInterval = setInterval(() => {
              if (canShoot && !isGameOver) {
                shoot(car, true);
              }
            }, RELOAD_TIME + 50); // Tambah sedikit delay untuk memastikan reload selesai
          }
        }

        // Fungsi untuk menghentikan auto-shooting
        function stopAutoShoot() {
          isHolding = false;
          if (autoShootInterval) {
            clearInterval(autoShootInterval);
            autoShootInterval = null;
          }
        }

        // Setup shoot button controls dengan auto-shoot
        if (shootBtn) {
          // Touch events untuk tombol tembak
          shootBtn.addEventListener("touchstart", (e) => {
            e.preventDefault();
            startAutoShoot();
          });

          shootBtn.addEventListener("touchend", (e) => {
            e.preventDefault();
            stopAutoShoot();
          });

          // Mouse events untuk tombol tembak
          shootBtn.addEventListener("mousedown", (e) => {
            e.preventDefault();
            startAutoShoot();
          });

          shootBtn.addEventListener("mouseup", (e) => {
            stopAutoShoot();
          });

          shootBtn.addEventListener("mouseleave", (e) => {
            stopAutoShoot();
          });

          // Style untuk tombol tembak dan reload indicator
          const style = document.createElement("style");
          style.textContent = `
                #shootBtn {
                    background: rgba(255, 0, 0, 0.3) !important;
                    font-size: 30px !important;
                    position: relative;
                    overflow: hidden;
                }

                #shootBtn::after {
                    content: '';
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    height: 4px;
                    background: #ff0000;
                    transform: scaleX(0);
                    transform-origin: left;
                    transition: transform ${RELOAD_TIME}ms linear;
                }

                #shootBtn.reloading::after {
                    transform: scaleX(1);
                }

                .control-btn {
                    cursor: pointer;
                    user-select: none;
                    -webkit-user-select: none;
                    -moz-user-select: none;
                    -ms-user-select: none;
                }

                .control-btn:active {
                    transform: scale(0.95);
                    background: rgba(255, 255, 255, 0.5) !important;
                }
            `;
          document.head.appendChild(style);
        }

        // Keyboard controls dengan auto-shoot untuk tombol K
        document.addEventListener("keydown", (e) => {
          switch (e.key.toLowerCase()) {
            case "w":
            case "arrowup":
              isMovingForward = true;
              break;
            case "s":
            case "arrowdown":
              isMovingBackward = true;
              break;
            case "a":
            case "arrowleft":
              isTurningLeft = true;
              break;
            case "d":
            case "arrowright":
              isTurningRight = true;
              break;
            case "k":
              if (!isHolding) {
                startAutoShoot();
              }
              break;
          }
        });

        document.addEventListener("keyup", (e) => {
          switch (e.key.toLowerCase()) {
            case "w":
            case "arrowup":
              isMovingForward = false;
              break;
            case "s":
            case "arrowdown":
              isMovingBackward = false;
              break;
            case "a":
            case "arrowleft":
              isTurningLeft = false;
              break;
            case "d":
            case "arrowright":
              isTurningRight = false;
              break;
            case "k":
              stopAutoShoot();
              break;
          }
        });
      }

      function createBotLabel(index) {
        const canvas = document.createElement("canvas");
        canvas.width = 256; // Lebih besar
        canvas.height = 128;

        const context = canvas.getContext("2d");
        const texture = new THREE.CanvasTexture(canvas);

        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          depthTest: false,
          depthWrite: false,
          sizeAttenuation: false, // Penting: ukuran tetap di layar
        });

        const sprite = new THREE.Sprite(material);
        sprite.scale.set(0.1, 0.05, 1); // Sesuaikan skala sesuai kebutuhan
        sprite.renderOrder = 9999; // Pastikan render paling atas

        // Fungsi untuk update tampilan label
        sprite.updateLabel = function (hp) {
          context.clearRect(0, 0, canvas.width, canvas.height);

          // Background hitam semi-transparan
          context.fillStyle = "rgba(0, 0, 0, 0.8)";
          context.fillRect(0, 0, canvas.width, canvas.height);

          // Nama bot dengan outline
          context.font = "bold 48px Arial";
          context.textAlign = "center";
          context.strokeStyle = "black";
          context.lineWidth = 4;
          context.strokeText(`Bot ${index + 1}`, canvas.width / 2, 50);
          context.fillStyle = "#00ffff";
          context.fillText(`Bot ${index + 1}`, canvas.width / 2, 50);

          // HP Bar dengan outline
          context.strokeStyle = "black";
          context.lineWidth = 2;
          context.strokeRect(28, 70, 200, 20);

          // HP Bar background
          context.fillStyle = "rgba(255, 255, 255, 0.2)";
          context.fillRect(28, 70, 200, 20);

          // HP Bar
          const hpWidth = (hp / 10) * 200;
          const gradient = context.createLinearGradient(28, 70, 228, 90);
          gradient.addColorStop(0, "#00ff00");
          gradient.addColorStop(1, "#00ffaa");
          context.fillStyle = hp > 3 ? gradient : "#ff0000";
          context.fillRect(28, 70, hpWidth, 20);

          // HP Text dengan outline
          context.font = "bold 24px Arial";
          context.textAlign = "center";
          context.strokeStyle = "black";
          context.lineWidth = 3;
          context.strokeText(`${hp}/10`, canvas.width / 2, 105);
          context.fillStyle = "white";
          context.fillText(`${hp}/10`, canvas.width / 2, 105);

          texture.needsUpdate = true;
        };

        sprite.updateLabel(10); // Set nilai awal
        return sprite;
      }

      function updateBotPositions() {
        bots.forEach((bot) => {
          if (bot.label && bot.mesh) {
            // Update posisi label sesuai posisi bot
            bot.label.position.set(
              bot.mesh.position.x,
              bot.mesh.position.y + 4, // Posisikan di atas bot
              bot.mesh.position.z
            );
            // Pastikan label menghadap kamera
            bot.label.quaternion.copy(camera.quaternion);
          }
        });
      }

      function updateWheels() {
        car.children.forEach((child) => {
          if (child.geometry instanceof THREE.CylinderGeometry) {
            if (isMovingForward) {
              child.rotation.x += 0.1;
            } else if (isMovingBackward) {
              child.rotation.x -= 0.1;
            }
          }
        });
      }

      function createBot(index) {
        const botMesh = new THREE.Group();

        // Bot body
        const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
        const bodyMaterial = new THREE.MeshPhongMaterial({
          color: 0x0088ff,
          specular: 0x555555,
          shininess: 30,
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.8;
        body.castShadow = true;
        botMesh.add(body);

        // Bot wheels
        const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 32);
        const wheelMaterial = new THREE.MeshPhongMaterial({
          color: 0x333333,
          specular: 0x444444,
          shininess: 50,
        });

        const wheelPositions = [
          [-1, 0.4, 1.2],
          [1, 0.4, 1.2],
          [-1, 0.4, -1.2],
          [1, 0.4, -1.2],
        ];

        wheelPositions.forEach((pos) => {
          const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
          wheel.rotation.z = Math.PI / 2;
          wheel.position.set(...pos);
          wheel.castShadow = true;
          botMesh.add(wheel);
        });

        // Add turret
        const turret = createTurret();
        turret.position.y = 1.5;
        botMesh.add(turret);

        // Buat label untuk bot
        const label = createBotLabel(index);

        // Set posisi bot
        const spawnRadius = (ROAD_SIZE / 2) * 0.8;
        const angle = ((Math.PI * 2) / numberOfBots) * index;
        botMesh.position.set(
          Math.cos(angle) * spawnRadius,
          0.4,
          Math.sin(angle) * spawnRadius
        );
        botMesh.rotation.y = Math.random() * Math.PI * 2;

        // Tambahkan bot ke dalam scene
        const bot = {
          mesh: botMesh,
          label: label, // Simpan referensi ke label
          hp: 10,
          rotation: botMesh.rotation.y,
          state: "roaming",
          timer: Math.random() * 100,
          targetPoint: new THREE.Vector3(),
          canShoot: true,
          targetingPlayer: false,
          lastShootTime: 0,
        };

        // Tambahkan bot dan label ke scene
        scene.add(botMesh);
        scene.add(label); // Tambahkan label langsung ke scene

        botsHp.set(bot.mesh.id, 10); // Set HP bot

        return bot;
      }

      // Tambahkan fungsi createBotBase
      function createBotBase(index) {
        const botGeometry = new THREE.Group();

        // Bot body
        const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
        const bodyMaterial = new THREE.MeshPhongMaterial({
          color: 0x0088ff, // Warna biru
          specular: 0x555555,
          shininess: 30,
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.8;
        body.castShadow = true;
        botGeometry.add(body);

        // Bot wheels
        const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 32);
        const wheelMaterial = new THREE.MeshPhongMaterial({
          color: 0x333333,
          specular: 0x444444,
          shininess: 50,
        });

        const wheelPositions = [
          [-1, 0.4, 1.2],
          [1, 0.4, 1.2],
          [-1, 0.4, -1.2],
          [1, 0.4, -1.2],
        ];

        wheelPositions.forEach((pos) => {
          const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
          wheel.rotation.z = Math.PI / 2;
          wheel.position.set(...pos);
          wheel.castShadow = true;
          botGeometry.add(wheel);
        });

        // Add turret
        const turret = createTurret();
        turret.position.y = 1.5;
        botGeometry.add(turret);

        // Set initial position
        const spawnRadius = (ROAD_SIZE / 2) * 0.8;
        const angle = ((Math.PI * 2) / numberOfBots) * index;
        botGeometry.position.set(
          Math.cos(angle) * spawnRadius,
          0.4,
          Math.sin(angle) * spawnRadius
        );

        botGeometry.rotation.y = Math.random() * Math.PI * 2;
        botGeometry.userData.id = `bot-${index}`; // Add unique ID
        scene.add(botGeometry);

        return {
          mesh: botGeometry,
          rotation: Math.random() * Math.PI * 2,
          state: "roaming",
          timer: Math.random() * 100,
          targetPoint: new THREE.Vector3(),
        };
      }

      // Tambahkan juga fungsi untuk pergerakan bot
      function updateBotMovement(bot) {
        switch (bot.state) {
          case "roaming":
            bot.timer -= 1;
            if (bot.timer <= 0) {
              // Choose new random target point
              const angle = Math.random() * Math.PI * 2;
              const radius = (ROAD_SIZE / 2) * 0.8;
              bot.targetPoint.set(
                Math.cos(angle) * radius,
                0.4,
                Math.sin(angle) * radius
              );
              bot.state = "moving";
            }
            break;

          case "moving":
            // Calculate direction to target
            const directionToTarget = new THREE.Vector3()
              .subVectors(bot.targetPoint, bot.mesh.position)
              .normalize();

            // Calculate angle to target
            const targetAngle = Math.atan2(
              directionToTarget.x,
              directionToTarget.z
            );
            let angleDiff = targetAngle - bot.rotation;

            // Normalize angle difference
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            // Turn towards target
            if (Math.abs(angleDiff) > 0.1) {
              bot.rotation += Math.sign(angleDiff) * 0.02;
            }

            // Move forward
            const BOT_MOVE_SPEED = 0.3;
            bot.mesh.position.x += Math.sin(bot.rotation) * BOT_MOVE_SPEED;
            bot.mesh.position.z += Math.cos(bot.rotation) * BOT_MOVE_SPEED;
            bot.mesh.rotation.y = bot.rotation;

            // Check if reached target
            if (bot.mesh.position.distanceTo(bot.targetPoint) < 1) {
              bot.state = "roaming";
              bot.timer = Math.random() * 100 + 50;
            }

            // Keep within bounds
            const maxPos = (ROAD_SIZE / 2) * 0.9;
            bot.mesh.position.x = Math.max(
              -maxPos,
              Math.min(maxPos, bot.mesh.position.x)
            );
            bot.mesh.position.z = Math.max(
              -maxPos,
              Math.min(maxPos, bot.mesh.position.z)
            );
            break;
        }

        // Rotate wheels
        bot.mesh.children.forEach((child) => {
          if (child.geometry instanceof THREE.CylinderGeometry) {
            child.rotation.x += 0.1;
          }
        });
      }

      function removeBotAndRespawn(bot) {
        const index = bots.indexOf(bot);
        if (index > -1) {
          if (bot.label) scene.remove(bot.label);
          scene.remove(bot.mesh);
          bots.splice(index, 1);
        }
        checkAllBotsDefeated();
      }

      function createBullet(shooter, isPlayerBullet) {
        const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const bulletMaterial = new THREE.MeshPhongMaterial({
          color: isPlayerBullet ? 0xff0000 : 0x0088ff,
          emissive: isPlayerBullet ? 0xff0000 : 0x0088ff,
          emissiveIntensity: 0.5,
        });

        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Set posisi peluru sesuai dengan posisi penembak
        bullet.position.copy(shooter.position);
        bullet.position.y += 1.7; // Tinggi meriam

        // Set arah peluru
        const shooterRotation = isPlayerBullet
          ? carRotation
          : shooter.rotation.y;
        bullet.direction = new THREE.Vector3(
          Math.sin(shooterRotation),
          0,
          Math.cos(shooterRotation)
        );

        // Set properti tambahan
        bullet.isPlayerBullet = isPlayerBullet;
        bullet.createdAt = Date.now();

        // Tambahkan peluru ke scene dan daftar peluru
        scene.add(bullet);
        bullets.push(bullet);

        return bullet;
      }

      function updateBots() {
        bots.forEach((bot) => {
          switch (bot.state) {
            case "roaming":
              // Update bot timer
              bot.timer -= 1;
              if (bot.timer <= 0) {
                // Choose new random target point
                const angle = Math.random() * Math.PI * 2;
                const radius = (ROAD_SIZE / 2) * 0.8;
                bot.targetPoint.set(
                  Math.cos(angle) * radius,
                  0.4,
                  Math.sin(angle) * radius
                );
                bot.state = "moving";
              }
              break;

            case "moving":
              // Calculate direction to target
              const directionToTarget = new THREE.Vector3()
                .subVectors(bot.targetPoint, bot.mesh.position)
                .normalize();

              // Calculate angle to target
              const targetAngle = Math.atan2(
                directionToTarget.x,
                directionToTarget.z
              );
              const currentAngle = bot.rotation;
              let angleDiff = targetAngle - currentAngle;

              // Normalize angle difference
              while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
              while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

              // Turn towards target
              if (Math.abs(angleDiff) > 0.1) {
                bot.rotation += Math.sign(angleDiff) * BOT_TURN_SPEED;
              }

              // Move forward
              bot.mesh.position.x += Math.sin(bot.rotation) * BOT_SPEED;
              bot.mesh.position.z += Math.cos(bot.rotation) * BOT_SPEED;
              bot.mesh.rotation.y = bot.rotation;

              // Check if reached target
              if (bot.mesh.position.distanceTo(bot.targetPoint) < 1) {
                bot.state = "roaming";
                bot.timer = Math.random() * 100 + 50;
              }

              // Keep within bounds
              const maxPos = (ROAD_SIZE / 2) * 0.9;
              bot.mesh.position.x = Math.max(
                -maxPos,
                Math.min(maxPos, bot.mesh.position.x)
              );
              bot.mesh.position.z = Math.max(
                -maxPos,
                Math.min(maxPos, bot.mesh.position.z)
              );
              break;
          }

          // Rotate wheels
          bot.mesh.children.forEach((child) => {
            if (child.geometry instanceof THREE.CylinderGeometry) {
              child.rotation.x += 0.1;
            }
          });
        });
      }

      // Fungsi baru untuk inisialisasi game setelah input bot
      function initGame() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        setupLighting();
        createRoad();
        createCar();

        // Create bots
        for (let i = 0; i < numberOfBots; i++) {
          bots.push(createBot(i));
        }

        camera.position.set(0, 20, -20);
        setupControls();
        animate();
      }
      // Fungsi untuk membuat meriam
      function createTurret() {
        const turretGroup = new THREE.Group();

        // Base meriam
        const baseGeometry = new THREE.CylinderGeometry(0.3, 0.4, 0.3, 8);
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.15;
        turretGroup.add(base);

        // Laras meriam
        const barrelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
        const barrelMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
        const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
        barrel.rotation.z = -Math.PI / 2;
        barrel.position.y = 0.2;
        barrel.position.z = 0.5;
        turretGroup.add(barrel);

        return turretGroup;
      }

      function shoot(shooter, isPlayer = true) {
        if (!canShoot || isGameOver || !shooter) return;

        createBullet(shooter, isPlayer);
        canShoot = false;

        // Update visual feedback pada tombol tembak
        const shootBtn = document.getElementById("shootBtn");
        if (shootBtn) {
          shootBtn.classList.add("reloading");

          setTimeout(() => {
            canShoot = true;
            shootBtn.classList.remove("reloading");
          }, RELOAD_TIME);
        } else {
          setTimeout(() => {
            canShoot = true;
          }, RELOAD_TIME);
        }
      }

      function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          if (!bullet) continue;

          // Move bullet
          bullet.position.x += bullet.direction.x * BULLET_SPEED;
          bullet.position.z += bullet.direction.z * BULLET_SPEED;

          // Check collision first
          if (handleBulletCollision(bullet)) {
            continue;
          }

          // Check boundaries and lifetime
          const halfRoad = ROAD_SIZE / 2;
          if (
            Math.abs(bullet.position.x) > halfRoad ||
            Math.abs(bullet.position.z) > halfRoad ||
            Date.now() - bullet.createdAt > BULLET_LIFETIME
          ) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }
      }

      // Tambahkan HTML untuk tombol tembak
      function addShootButton() {
        const shootBtn = document.createElement("button");

        const controlsRight = document.querySelector(".controls-right");
      }

      // Tambahkan CSS untuk animasi reload
      const styleSheet = document.createElement("style");
      styleSheet.textContent = `
                              @keyframes reloadAnimation {
                                  0% { transform: scale(1); opacity: 1; }
                                  50% { transform: scale(0.8); opacity: 0.5; }
                                  100% { transform: scale(1); opacity: 1; }
                              }

                              .reloading {
                                  animation: reloadAnimation 1s linear;
                              }

                              .hp-display {
                                  position: fixed;
                                  padding: 10px 20px;
                                  background: rgba(0, 0, 0, 0.7);
                                  color: white;
                                  border-radius: 5px;
                                  font-family: Arial, sans-serif;
                                  z-index: 1000;
                              }

                              #playerHp {
                                  top: 20px;
                                  left: 20px;
                              }

                              #targetedBy {
                                  top: 60px;
                                  left: 20px;
                                  color: #ff4444;
                              }

                              .game-over {
                                  position: fixed;
                                  top: 50%;
                                  left: 50%;
                                  transform: translate(-50%, -50%);
                                  background: rgba(0, 0, 0, 0.9);
                                  padding: 20px;
                                  border-radius: 10px;
                                  text-align: center;
                                  color: white;
                                  z-index: 1001;
                              }

                              .game-over button {
                                  margin-top: 20px;
                                  padding: 10px 20px;
                                  background: #4CAF50;
                                  border: none;
                                  border-radius: 5px;
                                  color: white;
                                  cursor: pointer;
                              }
                          `;
      document.head.appendChild(styleSheet);

      // Tambahkan UI untuk HP
      function createHpDisplay() {
        const playerHpDiv = document.createElement("div");
        playerHpDiv.id = "playerHp";
        playerHpDiv.className = "hp-display";
        document.body.appendChild(playerHpDiv);

        const targetedByDiv = document.createElement("div");
        targetedByDiv.id = "targetedBy";
        targetedByDiv.className = "hp-display";
        document.body.appendChild(targetedByDiv);

        updateHpDisplay();
      }

      function updateHpDisplay() {
        const playerHpDiv = document.getElementById("playerHp");
        playerHpDiv.innerHTML = `Player HP: ${playerHp}`;
      }

      // Tambahkan sistem shooting untuk bot
      function updateBotAI(bot) {
        if (!car || !bot.mesh) return; // Early return if objects don't exist

        // Check line of sight to player
        const directionToPlayer = new THREE.Vector3()
          .subVectors(car.position, bot.mesh.position)
          .normalize();
        const distance = bot.mesh.position.distanceTo(car.position);

        // Calculate angle to player
        const angleToPlayer = Math.atan2(
          directionToPlayer.x,
          directionToPlayer.z
        );
        const botRotation = bot.rotation;
        let angleDiff = angleToPlayer - botRotation;

        // Normalize angle
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

        // If player is in range and in front of bot
        if (distance < 30 && Math.abs(angleDiff) < 0.5) {
          bot.targetingPlayer = true;

          // Shoot if cooldown is ready
          const currentTime = Date.now();
          if (currentTime - bot.lastShootTime > RELOAD_TIME) {
            createBullet(bot.mesh, false);
            bot.lastShootTime = currentTime;
          }
        } else {
          bot.targetingPlayer = false;
        }

        updateTargetingIndicator();
      }

      function updateTargetingIndicator() {
        const targetedByDiv = document.getElementById("targetedBy");
        if (!targetedByDiv) return; // Early return if element doesn't exist

        const targetingBots = Array.from(bots).filter(
          (bot) => bot.targetingPlayer
        ).length;

        if (targetingBots > 0) {
          targetedByDiv.textContent = `Targeted by ${targetingBots} bot${
            targetingBots > 1 ? "s" : ""
          }!`;
          targetedByDiv.style.display = "block";
        } else {
          targetedByDiv.style.display = "none";
        }
      }

      function handleBulletCollision(bullet) {
        if (bullet.isPlayerBullet) {
          // Check collision with bots
          for (let bot of bots) {
            if (
              bot &&
              bot.mesh &&
              bullet.position.distanceTo(bot.mesh.position) < 2
            ) {
              bot.hp -= 1;
              if (bot.label) {
                bot.label.updateLabel(bot.hp);
              }
              scene.remove(bullet);
              bullets = bullets.filter((b) => b !== bullet);

              if (bot.hp <= 0) {
                scene.remove(bot.label); // Hapus label saat bot mati
                removeBotAndRespawn(bot);
              }
              return true;
            }
          }
        } else {
          // Check collision with player
          if (car) {
            const distance = bullet.position.distanceTo(car.position);
            if (distance < 2) {
              playerHp -= 1;
              if (playerLabelSystem) {
                playerLabelSystem.updateLabel(playerHp);
              }

              scene.remove(bullet);
              const index = bullets.indexOf(bullet);
              if (index > -1) {
                bullets.splice(index, 1);
              }

              if (playerHp <= 0) {
                showGameOver();
              }
              return true;
            }
          }
        }
        return false;
      }

      function updateLabels() {
        if (!camera || !tempQuaternion) return;

        camera.getWorldQuaternion(tempQuaternion);

        // Update player label
        if (car?.labelSystem?.sprite) {
          car.labelSystem.sprite.quaternion.copy(tempQuaternion);
        }

        // Update bot labels dan pastikan mereka terlihat
        bots.forEach((bot) => {
          if (bot?.labelSystem?.sprite) {
            bot.labelSystem.sprite.quaternion.copy(tempQuaternion);
            bot.labelSystem.sprite.renderOrder = 999;
            bot.labelSystem.sprite.material.depthTest = false;
          }
        });
      }

      function createLabel(name) {
        const canvas = document.createElement("canvas");
        // Perbesar canvas untuk player
        canvas.width = name === "Player" ? 200 : 100; // 2x lebih besar untuk player
        canvas.height = name === "Player" ? 100 : 50;
        const context = canvas.getContext("2d");

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({
          map: texture,
          transparent: true,
          depthTest: false,
          depthWrite: false, // Tambahan untuk memastikan visibilitas
          sizeAttenuation: true,
        });

        const sprite = new THREE.Sprite(material);

        // Perbesar skala untuk player
        if (name === "Player") {
          sprite.scale.set(3, 1.5, 1); // 2x lebih besar dari sebelumnya
        } else {
          sprite.scale.set(2, 1, 1);
        }

        function updateLabel(hp) {
          context.clearRect(0, 0, canvas.width, canvas.height);

          // Background
          context.fillStyle = "rgba(0, 0, 0, 0.7)";
          context.fillRect(0, 0, canvas.width, canvas.height);

          // Nama dengan ukuran lebih besar untuk player
          if (name === "Player") {
            context.font = "bold 32px Arial"; // 2x lebih besar
            context.fillStyle = "white";
            context.textAlign = "center";
            context.fillText(name, canvas.width / 2, 40);

            // HP Bar lebih besar untuk player
            context.fillStyle = "rgba(255, 255, 255, 0.3)";
            context.fillRect(20, 50, 160, 16); // 2x lebih besar

            const hpWidth = Math.max(0, (hp / 10) * 160);
            context.fillStyle = hp > 3 ? "#00ff00" : "#ff0000";
            context.fillRect(20, 50, hpWidth, 16);

            // HP Text lebih besar
            context.font = "28px Arial";
            context.fillStyle = "white";
            context.fillText(`${hp}/10`, canvas.width / 2, 85);
          } else {
            // Label bot (tetap sama ukurannya)
            context.font = "bold 16px Arial";
            context.fillStyle = "white";
            context.textAlign = "center";
            context.fillText(name, canvas.width / 2, 20);

            context.fillStyle = "rgba(255, 255, 255, 0.3)";
            context.fillRect(10, 25, 80, 8);

            const hpWidth = Math.max(0, (hp / 10) * 80);
            context.fillStyle = hp > 3 ? "#00ff00" : "#ff0000";
            context.fillRect(10, 25, hpWidth, 8);

            context.font = "14px Arial";
            context.fillStyle = "white";
            context.fillText(`${hp}/10`, canvas.width / 2, 45);
          }

          texture.needsUpdate = true;
        }

        updateLabel(10);
        return { sprite, updateLabel };
      }

      function startNewRound() {
        const newBotCount = parseInt(
          document.getElementById("newBotCount").value
        );
        if (newBotCount > 0 && newBotCount <= 50) {
          // Remove selection screen
          const selectionDiv = document.querySelector(
            'div[style*="position: fixed"]'
          );
          if (selectionDiv) {
            document.body.removeChild(selectionDiv);
          }

          // Reset game state
          numberOfBots = newBotCount;
          playerHp = 10;
          if (car && car.labelSystem) {
            car.labelSystem.updateLabel(playerHp);
          }

          // Clear existing bots
          bots.forEach((bot) => {
            if (bot.mesh) {
              scene.remove(bot.mesh);
            }
          });
          bots = [];

          // Create new bots
          for (let i = 0; i < numberOfBots; i++) {
            bots.push(createBot(i));
          }

          isGameOver = false;
          animate();
        }
      }

      function checkAllBotsDefeated() {
        const livingBots = bots.filter((bot) => bot.hp > 0);
        if (livingBots.length === 0) {
          showBotSelectionScreen();
        }
      }

      function restartGame() {
        // Reset player
        playerHp = 10;
        if (playerLabelSystem) {
          playerLabelSystem.updateLabel(playerHp);
        }

        // Reset posisi dan rotasi mobil pemain
        car.position.set(0, 0.4, 0);
        carRotation = 0;

        // Bersihkan bot dari scene dan array bots
        bots.forEach((bot) => {
          if (bot && bot.mesh) {
            scene.remove(bot.mesh);
            if (bot.label) scene.remove(bot.label); // Pastikan label juga dihapus
          }
        });
        bots = [];

        // Buat bot baru sesuai jumlah yang dipilih
        for (let i = 0; i < numberOfBots; i++) {
          bots.push(createBot(i));
        }

        // Bersihkan peluru dari scene dan array bullets
        bullets.forEach((bullet) => {
          scene.remove(bullet);
        });
        bullets = [];

        // Set ulang game state
        isGameOver = false;

        // Panggil animate untuk melanjutkan animasi
        animate();
      }
    </script>
  </body>
</html>
